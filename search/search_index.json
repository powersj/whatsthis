{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"whatsthis","text":"<p>Am I on a cloud, in a container, virtualized, or plain bare metal?</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>whatsthis is a Go-based CLI and library to determine where a system is running and what makes up the system.</p> <p>To determine where a system is running, whatsthis will attempt to make a best-effort guess based on a variety of heuristics as to what container, virtualization, or cloud the system is running on. This is similar to an all-in-one collection of the <code>systemd-detect-virt</code>, <code>virt-what</code>, and <code>cloud-id</code> commands.</p> <p>To summarize the system components, whatsthis will scan the filesystem for known files in <code>/sys</code>, <code>/proc</code>, or other directories. This data is then used to create a short summarize of the system in place of running several other commands (e.g. <code>lsblk</code>, <code>ip</code>, <code>dmesg</code>, <code>dmidecode</code>)</p>"},{"location":"#install","title":"Install","text":"<p>For complete details on how to install from binary, source, or from go, check out the install page for more information. This page also details the support for architectures and operating systems.</p> <p>See the latest release page for the available binary downloads.</p>"},{"location":"#cli","title":"CLI","text":"<p>To get a full summary of the system run whatsthis and the output will show a breakdown module name by module name:</p> <pre><code>$ whatsthis\n---\ncloud: not detected\nvirt: not detected\ncontainer: not detected\n---\ndistro: Ubuntu 20.10 (amd64)\nkernel: 5.8.0-33-generic\n---\nboard: ASUSTeK COMPUTER INC. TUF GAMING X570-PRO (WI-FI)\nbios: American Megatrends Inc. BIOS 3001 (12/04/2020)\ncpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket\nmemory: 31.3G\nnetwork:\n  adapters:\n    - enp6s0 24:4b:fe:9a:a4:fa 1000 mtu 9000 (igc)\n  virtual:\n    - virbr0-nic 52:54:00:6d:53:f1 mtu 1500\n  bridges:\n    - docker0 02:42:96:01:ec:70 mtu 1500\n    - virbr0 52:54:00:6d:53:f1 mtu 1500\nstorage:\n  nvme0n1 931.5G:\n    - nvme0n1p1 512M EFI System Partition\n    - nvme0n1p2 931G\n  nvme1n1 1.9T:\n    - nvme1n1p4 498M\n    - nvme1n1p2 16M Microsoft reserved partition\n    - nvme1n1p3 1.9T Basic data partition\n    - nvme1n1p1 100M EFI system partition\n</code></pre> <p>To run only one particular module, run with only that module name:</p> <pre><code>$ whatsthis cpu\ncpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket\n</code></pre> <p>Finally, to get the output in JSON add the <code>--json</code> flag:</p> <pre><code>$ whatsthis cpu --json\n{\n  \"model\": \"AMD Ryzen 9 5950X 16-Core Processor\",\n  \"numCore\": 16,\n  \"numThread\": 32,\n  \"numSocket\": 1\n}\n</code></pre> <p>See <code>whatsthis help</code> for a full list of modules and more information on options.</p>"},{"location":"#api","title":"API","text":"<p>whatsthis offers several structs and functions to help determine the cloud, container, virtualization, and the underlying hardware of a system. Users can take advantage of these in their own code:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n\n  \"github.com/powersj/whatsthis\"\n)\n\nfunc main() {\n  cloud, err := whatsthis.Cloud()\n  if err != nil {\n    fmt.Printf(\"Error getting cloud info: %v\", err)\n  }\n\n  if cloud.Detected {\n    fmt.Printf(cloud.Name)\n  }\n}\n</code></pre>"},{"location":"#support","title":"Support","text":"<p>If you find a bug, have a question, or ideas for improvements please file an issue on GitHub.</p>"},{"location":"cli/","title":"CLI","text":"<p>To get a full summary of the system run whatsthis and the output will show a breakdown probe by probe:</p> <pre><code>$ whatsthis\n---\ncloud: not detected\nvirt: not detected\ncontainer: not detected\n---\ndistro: Ubuntu 20.10 (amd64)\nkernel: 5.8.0-33-generic\n---\nboard: ASUSTeK COMPUTER INC. TUF GAMING X570-PRO (WI-FI)\nbios: American Megatrends Inc. BIOS 3001 (12/04/2020)\ncpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket\nmemory: 31.3G\nnetwork:\n- adapters:\n  - enp6s0 24:4b:fe:9a:a4:fa 1000 mtu 9000 (igc)\n- virtual:\n  - virbr0-nic 52:54:00:6d:53:f1 mtu 1500\n- bridges:\n  - docker0 02:42:96:01:ec:70 mtu 1500\n  - virbr0 52:54:00:6d:53:f1 mtu 1500\nstorage:\n- nvme0n1 931.5G\n  - nvme0n1p1 512M EFI System Partition\n  - nvme0n1p2 931G\n- nvme1n1 1.9T\n  - nvme1n1p4 498M\n  - nvme1n1p2 16M Microsoft reserved partition\n  - nvme1n1p3 1.9T Basic data partition\n  - nvme1n1p1 100M EFI system partition\n</code></pre>"},{"location":"cli/#subcommands","title":"Subcommands","text":"<p>To run only one particular probe, run with only that probe name:</p> <pre><code>$ whatsthis cpu\ncpu: AMD Ryzen 9 5950X 16-Core Processor with 16 cores (32 threads) on 1 socket\n</code></pre> <p>There are subcommands for the following probes:</p> <ul> <li>cloud</li> <li>container</li> <li>cpu</li> <li>distro</li> <li>memory</li> <li>network</li> <li>platform</li> <li>storage</li> <li>virt</li> </ul>"},{"location":"cli/#json-output","title":"JSON output","text":"<p>All commands can take the <code>--json</code> flag to produce JSON output:</p> <pre><code>$ whatsthis cpu --json\n{\n  \"model\": \"AMD Ryzen 9 5950X 16-Core Processor\",\n  \"numCore\": 16,\n  \"numThread\": 32,\n  \"numSocket\": 1\n}\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>Below outlines the various ways to obtain and install whatsthis.</p>"},{"location":"install/#from-binary","title":"From binary","text":"<p>Download the latest release of whatsthis for your platform and extract the tarball:</p> <pre><code>wget whatsthis_&lt;version&gt;_&lt;os&gt;_&lt;arch&gt;.tar.gz\ntar zxvf whatsthis_&lt;version&gt;_&lt;os&gt;_&lt;arch&gt;.tar.gz\n</code></pre> <p>The tarball will extract the readme, license, and the pre-compiled binary.</p>"},{"location":"install/#from-source","title":"From source","text":"<p>To build and install whatsthis directly from source run:</p> <pre><code>git clone https://github.com/powersj/whatsthis\ncd whatsthis\nmake\n</code></pre> <p>The default make command will run <code>go build</code> and produce a whatsthis binary in the root directory.</p>"},{"location":"install/#from-go","title":"From go","text":"<p>To download using the <code>go get</code> command run:</p> <pre><code>go get github.com/powersj/whatsthis\n</code></pre> <p>The executable object file location will exist at <code>${GOPATH}/bin/whatsthis</code></p>"},{"location":"install/#architecture-support","title":"Architecture support","text":"<p>Releases include binaries for x86-64 (amd64) as well as some initial support for ARMv8 (arm64). The ARMv8 architecture does not have the same cpuid capabilities in place as x86-64 does. As such the virtualization detection on ARMv8 is not functional.</p> Architecture Support x86-64 yes ARMv8 limited ARMv6 none ppc64le none s390x none x86 none"},{"location":"install/#operating-system-support","title":"Operating system support","text":"<p>whatsthis was developed with Linux based OSes in mind.</p> Operating System Support Linux yes Darwin none FreeBSD none Windows none <p>FreeBSDs does not mount <code>/proc</code> by default and <code>/sys</code> is replaced by <code>sysctl</code>. whatsthis could learn how to use <code>sysctl</code> down the road. This could also help enable Darwin support.</p> <p>Additionally, Windows support could be learned by looking at the Windows Management Instrumentation (WMI).</p>"},{"location":"contributing/documentation/","title":"Documentation","text":"<p>The documentation is built with MkDocs and the Material for MkDocs theme and is written in Markdown.</p>"},{"location":"contributing/documentation/#building","title":"Building","text":"<p>To build the documentation site, first setup a Python virtual environment and install the mkdocs-material package, which will pull in all other dependencies:</p> <pre><code>virtualenv .venv\n. .venv/bin/activate\npip install mkdocs-material\n</code></pre> <p>To build the docs, use the makefile target:</p> <pre><code>make docs\n</code></pre> <p>Launch a web server to pull up the docs and then point a browser at http://0.0.0.0:8000/ to view the site:</p> <pre><code>python3 -m http.server --directory site/\n</code></pre>"},{"location":"contributing/overview/","title":"Contributing","text":""},{"location":"contributing/overview/#how-to-contribute","title":"How to contribute","text":"<p>I want your help. No really, I do.</p> <p>There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project.</p> <p>I assure you, that's not the case.</p> <p>This project has some clear Contribution Guidelines and expectations that you can read below.</p> <p>The contribution guidelines outline the process that you will need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute.</p> <p>And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.)</p> <p>Thank you for contributing!</p> <p>(The above is from Adrienne Lowe)</p>"},{"location":"contributing/overview/#getting-started","title":"Getting started","text":"<ul> <li>Fork the repository on GitHub</li> <li>Read the index.md for getting started and look through the   documentation for any other basic help.</li> <li>Play with the project on a variety of systems and environments, submit bugs,   and submit pull requests!</li> </ul>"},{"location":"contributing/overview/#developing-a-merge-request","title":"Developing a merge request","text":"<ul> <li>Find an issue or create your own.</li> <li>Create a feature or bug fix branch in your fork of the repo.</li> <li>Write your feature or fix your bug. Make commits of logical units.</li> <li>If needed, update the documentation in either the README or docs folder.</li> <li>Ensure the project passes the lint tests, builds, and tests pass.</li> <li>Push and submit your pull request!</li> </ul>"},{"location":"contributing/overview/#code-changes","title":"Code changes","text":"<p>The project has a basic CI setup already, which will run a lint, build, build the docs, and tests. These need to pass and I am more than willing to help you work through any issues you come across. This includes disabling or changing the config on the linters.</p> <p>These CI steps are very easy to run using the makefile via:</p> <pre><code>make lint\nmake build\nmake docs\nmake test\n</code></pre>"},{"location":"contributing/overview/#documentation-changes","title":"Documentation changes","text":"<p>If you are working on the documentation, ensure it continues to build using the steps outlined on the documentation page.</p>"},{"location":"contributing/overview/#commit-message","title":"Commit message","text":"<p>This is the rough convention I follow for commit messages:</p> <pre><code>topic: &lt;short title for what changed&gt;\n&lt;BLANK LINE&gt;\n&lt;why this change was made and what changed&gt;\n&lt;BLANK LINE&gt;\nFixes #1\n</code></pre> <p>The first line is the subject and should be no longer than 70 characters, the second line is always blank, and other lines should be wrapped at 80 characters.</p>"},{"location":"contributing/overview/#acceptance","title":"Acceptance","text":"<p>These things will make a PR more likely to be accepted:</p> <ul> <li>a well-described requirement</li> <li>tests for new code</li> <li>tests for old code!</li> <li>new code and tests follow the conventions in old code and tests</li> <li>a good commit message</li> </ul> <p>In general, I will merge a PR once I reviewed and approved it. Trivial changes (e.g., corrections to spelling) will get waved through. For substantial changes, you might get asked to resubmit the PR or divide the changes into more than one PR.</p>"},{"location":"contributing/roadmap/","title":"Roadmap","text":"<p>This is a collection of future ideas for the project.</p>"},{"location":"contributing/roadmap/#next","title":"Next","text":"<ul> <li>Examples: include how to use this to query specific subsystems inside a   go-lang project</li> <li>Greater debug output</li> </ul>"},{"location":"contributing/roadmap/#next-1","title":"Next + 1","text":"<ul> <li>Greater arm64 support for virtualization</li> <li>PCI IDs for network and storage devices</li> <li>whatsthis-collect: enable basic functionality to start capturing required   files</li> </ul>"},{"location":"contributing/roadmap/#next-2","title":"Next + 2","text":"<ul> <li>Custom source directory</li> <li>*BSD support</li> </ul>"},{"location":"contributing/versioning/","title":"Versioning","text":"<p>The project follows Sematic Versioning.</p>"},{"location":"contributing/versioning/#release-a-new-version","title":"Release a new version","text":"<p>The current under-development release version is kept in <code>app/whatsthis/cmd/root.go</code>:</p> <pre><code>const (\n    version = \"v1.2.0\"\n)\n</code></pre> <p>To release a new version create and push a new tag, then run the goreleaser:</p> <pre><code>git tag -a v1.2.0 -m \"Summary of release\"\ngit push origin v1.2.0\nmake release\n</code></pre> <p>This will create the corresponding GitHub Releases page and upload the artifacts to it.</p> <p>Then increment the version in <code>app/whatsthis/cmd/root.go</code> and push that change to open the next version:</p> <pre><code>git commit -am \"Open release v1.3.0\"\ngit push\n</code></pre>"},{"location":"probes/clouds/","title":"Clouds","text":""},{"location":"probes/clouds/#detection","title":"Detection","text":"<p>whatsthis attempts to identify if the system is running on a cloud based on various heuristics.</p>"},{"location":"probes/clouds/#supported","title":"Supported","text":""},{"location":"probes/clouds/#amazon-web-services","title":"Amazon Web Services","text":"<p>Amazon Web Services (AWS) has three types of instance platforms:</p> <ul> <li>Bare metal</li> <li>Nitro (KVM)</li> <li>HVM (Xen)</li> </ul> <p>Bare metal and Nitro (KVM) based instances will report \"Amazon EC2\" as the system vendor.</p> <p>The older Xen based systems (e.g t2) will report Xen. To further identify these systems the Hypervisor UUID will start with \"ec2\". These heuristics come from Amazon's website</p>"},{"location":"probes/clouds/#alibaba-cloud","title":"Alibaba Cloud","text":"<p>Alibaba instances report the product name as \"Alibaba Cloud ECS\".</p>"},{"location":"probes/clouds/#cloudsigma","title":"CloudSigma","text":"<p>CloudSigma instances report the product name as \"CloudSigma\".</p>"},{"location":"probes/clouds/#cloudstack","title":"CloudStack","text":"<p>CloudStack instances reported product name will start with \"CloudStack\".</p>"},{"location":"probes/clouds/#digital-ocean","title":"Digital Ocean","text":"<p>Digital Ocean instances report the system vendor as \"DigitalOcean\".</p>"},{"location":"probes/clouds/#exoscale","title":"Exoscale","text":"<p>Exoscale instances report the product name as \"Exoscale\".</p>"},{"location":"probes/clouds/#google-cloud-platform","title":"Google Cloud Platform","text":"<p>Google Cloud Platform instances report the product name as \"Google Compute Engine\".</p>"},{"location":"probes/clouds/#hetzner","title":"Hetzner","text":"<p>Hetzner instances report the system vendor as \"Hetzner\".</p>"},{"location":"probes/clouds/#microsoft-azure","title":"Microsoft Azure","text":"<p>Microsoft Azure instances report the chassis asset tag as the hard-coded value of \"7783-7084-3265-9085-8269-3286-77\".</p>"},{"location":"probes/clouds/#openstack","title":"OpenStack","text":"<p>OpenStack instances report system vendor as \"OpenStack Foundation\".</p>"},{"location":"probes/clouds/#oracle-cloud","title":"Oracle Cloud","text":"<p>Oracle cloud report the chassis asset tag as \"OracleCloud.com\".</p>"},{"location":"probes/clouds/#smartos","title":"SmartOS","text":"<p>SmartOS reports the product name start with \"SmartDC\".</p>"},{"location":"probes/clouds/#other","title":"Other","text":"<p>Other clouds that could be added at a future date include:</p> <ul> <li>IBM Cloud</li> </ul>"},{"location":"probes/containers/","title":"Containers","text":""},{"location":"probes/containers/#detection","title":"Detection","text":"<p>whatsthis attempts to identify if the system is running in a container based on a variety of heuristic.</p>"},{"location":"probes/containers/#supported","title":"Supported","text":""},{"location":"probes/containers/#docker","title":"docker","text":"<p>First look for the <code>/.dockerenv</code> file to identify a Docker container. Then look for \"docker\" inside <code>/proc/cgroups</code>.</p>"},{"location":"probes/containers/#lxc","title":"lxc","text":"<p>Looks for the string \"container=\" in <code>/proc/environ</code>.</p>"},{"location":"probes/containers/#podman","title":"podman","text":"<p>Per a GitHub issue on the podman project page, there is a guarantee that container environment variable will be set to \"podman\".</p> <p>The environment variable could be overridden by a user or image creator. As such, this looks for the <code>/run/.containerenv</code> file as well.</p>"},{"location":"probes/containers/#wsl","title":"wsl","text":"<p>Per a GitHub issue on the WSL project page, checking for \"microsoft\" in either of these two files:</p> <ul> <li><code>/proc/sys/kernel/osrelease</code></li> <li><code>/proc/version</code></li> </ul>"},{"location":"probes/containers/#other","title":"Other","text":"<p>For the initial development of the app, platforms were limited to those that could easily be tested. The are some additional container run-times that could be added at a later date:</p> <ul> <li><code>bottlerocket</code></li> <li><code>rkt</code>: however, per GitHub page no longer under   development</li> <li><code>openvz</code>: the commercial version, Virtuozzo is available, but otherwise   development appears to have ended</li> </ul>"},{"location":"probes/virtualization/","title":"Virtualization","text":""},{"location":"probes/virtualization/#detection","title":"Detection","text":"<p>whatsthis attempts to identify the system's virtualization platforms based on the result of the CPU identification instruction known as cpuid.</p> <p>The instruction was created to provide a mechanism for programmers to obtain the system's CPU model. Virtualization providers will set this string to provide a mechanism to determine what virtualization platform a system is running on.</p> <p>Bug</p> <p>As cpuid is only available on x86-64, virtualization support in aarch64 is currently non-existent. When running on aarch64, the function will always return an empty string and therefore never detect any virtualization platform correctly.</p>"},{"location":"probes/virtualization/#supported","title":"Supported","text":"<p>Below is a table of the currently known virtualization platforms and their corresponding advertised vendor ID found from cpuid:</p> Platform Vendor ID bhyve <code>bhyve bhyve</code> hyper-v <code>Microsoft Hv</code> kvm <code>KVMKVMKVM</code> parallels <code>lrpepyh vr</code> qemu <code>TCGTCGTCGTCG</code> vmware <code>VMwareVMware</code> xen <code>XenVMMXenVMM</code> <p>Note</p> <p>Using cpuid on these platforms provides a good first heuristic when attempting to determine the platform. However, there are cases where these platforms have additional product offerings and using the cpuid alone is not enough. Please feel free to file an issue if you come across one of these scenarios.</p>"},{"location":"probes/virtualization/#other","title":"Other","text":"<p>Other virtualization detection software like virt-what or imvirt have detection for other additional platforms. For the initial development of the app, platforms were limited to those that could easily be tested. The are some additional virtualization platforms that could be added at a later date:</p> <ul> <li>acrn</li> <li>bochs</li> <li>qnx</li> <li>lkvm</li> <li>uml</li> <li>virtual box</li> </ul>"},{"location":"testing/containers/","title":"Containers","text":"<p>Below are the test cases used to confirm container identification. These assume a user is running on Ubuntu 20.04 LTS or later. Essentially, each test case is to launch a container, copy the whatsthis binary over, and run it. Finally, confirm the container is correctly reported.</p>"},{"location":"testing/containers/#docker","title":"Docker","text":"<pre><code>snap install docker\ndocker run --detach --tty --name test ubuntu\ndocker cp whatsthis test:/\ndocker exec -it test /whatsthis\ndocker container rm --force test\n</code></pre>"},{"location":"testing/containers/#lxc","title":"LXC","text":"<pre><code>snap install lxc\nlxc launch ubuntu-daily:focal test\nlxc file push whatsthis test/root/whatsthis\nlxc exec test /root/whatsthis\nlxc delete --force test\n</code></pre>"},{"location":"testing/containers/#podman","title":"Podman","text":"<pre><code>snap install podman\npodman run --detach --tty --name test ubuntu\npodman cp whatsthis test:/\npodman exec -it test /whatsthis\npodman container rm --force test\n</code></pre>"},{"location":"testing/containers/#wsl","title":"WSL","text":""},{"location":"testing/containers/#enable-wsl","title":"Enable WSL","text":"<p>Open a PowerShell console as Administrator and run the following to enable WSL and WSL 2:</p> <pre><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n</code></pre> <p>There is an additional kernel update package required for download here. Once installed, reboot the system to begin using WSL.</p> <p>For more details see these official instructions here.</p>"},{"location":"testing/containers/#wsl-version","title":"WSL Version","text":"<p>To set WSL 2 as the default version run the following as Administrator in a PowerShell console:</p> <pre><code>wsl --set-default-version 2\n</code></pre> <p>It can be helpful to switch between WSL 1 and WSL 2 during testing. Users can list all distributions and change the version of any running distribution by running.</p> <pre><code>wsl --list --all\nwsl --set-version &lt;distro&gt; [2|1]\n</code></pre>"},{"location":"testing/containers/#testing","title":"Testing","text":"<p>Finally, to test the binary on a WSL distribution, copy it from your local filesystem by accessing it from <code>/mnt/c</code>:</p> <pre><code>cp /mnt/c/Users/&lt;username&gt;/Documents... whatthis\n./whatsthis\n</code></pre>"},{"location":"testing/hyperv/","title":"Hyper-V","text":""},{"location":"testing/hyperv/#enable-hyper-v","title":"Enable Hyper-V","text":"<p>Open a PowerShell console as Administrator and run the following and reboot the system:</p> <p><code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All</code></p> <p>For more details and options see the Install Hyper-V on Windows 10 documentation.</p>"},{"location":"testing/hyperv/#multipass","title":"Multipass","text":"<p>Multipass is a quick way to get an Ubuntu VM up and running. It is available on Windows, MacOS, and Linux. On Windows, if Hyper-V is enabled, it can take advantage of Hyper-V.</p> <p>Once downloaded and installed, a user can launch a VM in PowerShell, transfer a test binary, and test it with:</p> <pre><code>multipass launch focal --name test\nmultipass transfer whatsthis test:/home/ubuntu/whatsthis\nmultipass exec test ./whatsthis\nmultipass delete --force test\n</code></pre>"},{"location":"testing/kvm/","title":"KVM","text":"<p>The following describes how to launch a KVM system on Ubuntu in order to test the KVM detection.</p>"},{"location":"testing/kvm/#multipass","title":"Multipass","text":"<p>Multipass is a quick way to get an Ubuntu VM up and running. It is available on Windows, MacOS, and Linux. On Linux, Multipass will launch using QEMU with KVM.</p> <p>To get a Multipass VM on Ubuntu setup to test whatsthis run the following:</p> <pre><code>snap install multipass\nmultipass launch focal --name test\nmultipass transfer whatsthis test:/home/ubuntu/whatsthis\nmultipass exec test ./whatsthis\nmultipass delete --force test\n</code></pre>"},{"location":"testing/kvm/#cli","title":"CLI","text":"<p>These instructions are identical to the QEMU instructions except for the addition of the \"-enable-kvm\" option used during the launch of the VM.</p> <p>First, create some user-data to pass the VM that will setup the 'ubuntu' user with the password of 'password'. Also set your GitHub ID and it will automatically import your SSH key into the VM:</p> <pre><code>export GITHUB_ID=&lt;GITHUB_ID&gt;\nsudo apt update\nsudo apt install --yes cloud-image-utils\ncat &gt; user-data.yaml &lt;&lt;EOF\n#cloud-config\npassword: password\nchpasswd:\n    expire: False\nssh_pwauth: True\nssh_import_id:\n    - gh:$GITHUB_ID\nEOF\ncloud-localds seed.img user-data.yaml\n</code></pre> <p>Get the latest Ubuntu 20.04 LTS (Focal) image and launch the VM:</p> <pre><code>wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img\nqemu-system-x86_64 -enable-kvm -m 2048 -nographic -snapshot \\\n    -netdev id=net00,type=user,hostfwd=tcp::2222-:22 \\\n    -device virtio-net-pci,netdev=net00 \\\n    -drive if=virtio,format=qcow2,file=focal-server-cloudimg-amd64.img \\\n    -drive if=virtio,format=raw,file=seed.img\n</code></pre> <p>Once the system has booted, transfer a local test binary run:</p> <pre><code>rsync -e \"ssh -p 2222\" whatsthis ubuntu@0.0.0.0:/home/ubuntu/whatsthis\n</code></pre> <p>Then either login with <code>ubuntu</code> and <code>password</code> or SSH to the system using:</p> <pre><code>ssh -o \"StrictHostKeyChecking no\" ubuntu@0.0.0.0 -p 2222\n</code></pre> <p>When done to close out of the qemu process using the escape sequence:</p> <pre><code>Ctrl-a c\n(qemu) quit\n</code></pre>"},{"location":"testing/qemu/","title":"QEMU","text":"<p>The following describes how to launch a QEMU system on Ubuntu in order to test the QEMU detection. These instructions are identical to the KVM CLI instructions except for the absence of the '-enable-kvm' option.</p> <p>First, create some user-data to pass the VM that will setup the 'ubuntu' user with the password of 'password'. Also set your GitHub ID and it will automatically import your SSH key into the VM:</p> <pre><code>export GITHUB_ID=&lt;GITHUB_ID&gt;\nsudo apt update\nsudo apt install --yes cloud-image-utils\ncat &gt; user-data.yaml &lt;&lt;EOF\n#cloud-config\npassword: password\nchpasswd:\n    expire: False\nssh_pwauth: True\nssh_import_id:\n    - gh:$GITHUB_ID\nEOF\ncloud-localds seed.img user-data.yaml\n</code></pre> <p>Get the latest Ubuntu 20.04 LTS (Focal) image and launch the VM:</p> <pre><code>wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img\nqemu-system-x86_64 -m 2048 -nographic -snapshot \\\n    -netdev id=net00,type=user,hostfwd=tcp::2222-:22 \\\n    -device virtio-net-pci,netdev=net00 \\\n    -drive if=virtio,format=qcow2,file=focal-server-cloudimg-amd64.img \\\n    -drive if=virtio,format=raw,file=seed.img\n</code></pre> <p>Once the system has booted, and this will take a considerable amount of time due to the emulation, transfer a local test binary run:</p> <pre><code>rsync -e \"ssh -p 2222\" whatsthis ubuntu@0.0.0.0:/home/ubuntu/whatsthis\n</code></pre> <p>Then either login with <code>ubuntu</code> and <code>password</code> or SSH to the system using:</p> <pre><code>ssh -o \"StrictHostKeyChecking no\" ubuntu@0.0.0.0 -p 2222\n</code></pre> <p>When done to close out of the qemu process using the escape sequence:</p> <pre><code>Ctrl-a c\n(qemu) quit\n</code></pre>"}]}